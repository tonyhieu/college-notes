<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Computational Geometry | Anthony Vo’s College Notes</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Computational Geometry" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="COMPSCI 164" />
<meta property="og:description" content="COMPSCI 164" />
<link rel="canonical" href="https://tonyhieu.github.io/college-notes/cs164/lecture/fall24/markdown/2024/09/26/cs-164-lecture.html" />
<meta property="og:url" content="https://tonyhieu.github.io/college-notes/cs164/lecture/fall24/markdown/2024/09/26/cs-164-lecture.html" />
<meta property="og:site_name" content="Anthony Vo’s College Notes" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-09-26T00:00:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Computational Geometry" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-09-26T00:00:00-05:00","datePublished":"2024-09-26T00:00:00-05:00","description":"COMPSCI 164","headline":"Computational Geometry","mainEntityOfPage":{"@type":"WebPage","@id":"https://tonyhieu.github.io/college-notes/cs164/lecture/fall24/markdown/2024/09/26/cs-164-lecture.html"},"url":"https://tonyhieu.github.io/college-notes/cs164/lecture/fall24/markdown/2024/09/26/cs-164-lecture.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/college-notes/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://tonyhieu.github.io/college-notes/feed.xml" title="Anthony Vo's College Notes" /><link rel="shortcut icon" type="image/x-icon" href="/college-notes/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/college-notes/">Anthony Vo&#39;s College Notes</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/college-notes/schedule/">Class Schedule</a><a class="page-link" href="/college-notes/labs/">Labs</a><a class="page-link" href="/college-notes/categories/">Tags</a><a class="page-link" href="/college-notes/search/">Search</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Computational Geometry</h1><p class="page-description">COMPSCI 164</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2024-09-26T00:00:00-05:00" itemprop="datePublished">
        Sep 26, 2024
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      20 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/college-notes/categories/#cs164">cs164</a>
        &nbsp;
      
        <a class="category-tags-link" href="/college-notes/categories/#lecture">lecture</a>
        &nbsp;
      
        <a class="category-tags-link" href="/college-notes/categories/#fall24">fall24</a>
        &nbsp;
      
        <a class="category-tags-link" href="/college-notes/categories/#markdown">markdown</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#baseline">Baseline</a></li>
<li class="toc-entry toc-h2"><a href="#convex-hull">Convex Hull</a>
<ul>
<li class="toc-entry toc-h3"><a href="#line-sweep-algorithm">Line Sweep Algorithm</a></li>
<li class="toc-entry toc-h3"><a href="#gift-wrapping-jarvis-march">Gift Wrapping (Jarvis March)</a></li>
<li class="toc-entry toc-h3"><a href="#divide-and-conquer">Divide and Conquer</a></li>
<li class="toc-entry toc-h3"><a href="#quick-hull">Quick Hull</a></li>
<li class="toc-entry toc-h3"><a href="#randomized-quickhull">Randomized Quickhull</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#line-segment-intersections">Line Segment Intersections</a>
<ul>
<li class="toc-entry toc-h3"><a href="#plane-sweep-algorithm">Plane Sweep Algorithm</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#doubly-connected-edge-list-dcel">Doubly Connected Edge List (DCEL)</a>
<ul>
<li class="toc-entry toc-h3"><a href="#computing-map-overlay">Computing Map Overlay</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#polygon-triangulation-art-gallery-guarding-problem">Polygon Triangulation (Art Gallery Guarding Problem)</a>
<ul>
<li class="toc-entry toc-h3"><a href="#triangulating-a-polygon">Triangulating a Polygon</a>
<ul>
<li class="toc-entry toc-h4"><a href="#plane-sweep-algorithm-1">Plane Sweep Algorithm</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#creating-monotone-polygons">Creating Monotone Polygons</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#lower-envelope">Lower Envelope</a>
<ul>
<li class="toc-entry toc-h3"><a href="#dc-algorithm">D&amp;C Algorithm</a>
<ul>
<li class="toc-entry toc-h4"><a href="#sweep-line-merge">Sweep Line Merge</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#linear-programming">Linear Programming</a>
<ul>
<li class="toc-entry toc-h3"><a href="#half-plane-intersection">Half-Plane Intersection</a></li>
<li class="toc-entry toc-h3"><a href="#incremental-linear-programming">Incremental Linear Programming</a></li>
<li class="toc-entry toc-h3"><a href="#seidels-algorithm">Seidel’s Algorithm</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#orthogonal-range-searching">Orthogonal Range Searching</a>
<ul>
<li class="toc-entry toc-h3"><a href="#1d-case">1D Case</a></li>
<li class="toc-entry toc-h3"><a href="#naive-2d-case">Naive 2D Case</a></li>
<li class="toc-entry toc-h3"><a href="#better-2d-fractional-cascading">Better 2D: Fractional Cascading</a></li>
<li class="toc-entry toc-h3"><a href="#d-dimension-case">d-Dimension Case</a></li>
<li class="toc-entry toc-h3"><a href="#kd-tree">KD tree</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#point-location">Point Location</a>
<ul>
<li class="toc-entry toc-h3"><a href="#slab-method">Slab Method</a></li>
<li class="toc-entry toc-h3"><a href="#plane-sweep">Plane Sweep</a></li>
<li class="toc-entry toc-h3"><a href="#kirkpatricks-point-location-algorithm">Kirkpatrick’s Point Location Algorithm</a>
<ul>
<li class="toc-entry toc-h4"><a href="#kirkpatricks-hierarchy">Kirkpatrick’s Hierarchy</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#voronoi-diagrams">Voronoi Diagrams</a>
<ul>
<li class="toc-entry toc-h3"><a href="#fortunes-sweep">Fortune’s Sweep</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#point-line-duality">Point Line Duality</a></li>
<li class="toc-entry toc-h2"><a href="#line-arrangements">Line Arrangements</a></li>
<li class="toc-entry toc-h2"><a href="#delaunay-triangulation">Delaunay Triangulation</a></li>
<li class="toc-entry toc-h2"><a href="#3d-convex-hull">3D Convex Hull</a>
<ul>
<li class="toc-entry toc-h3"><a href="#gift-wrapping">Gift Wrapping</a></li>
<li class="toc-entry toc-h3"><a href="#divide-and-conquer-1">Divide and Conquer</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#windowing">Windowing</a>
<ul>
<li class="toc-entry toc-h3"><a href="#interval-trees">Interval Trees</a></li>
<li class="toc-entry toc-h3"><a href="#priority-search-trees">Priority Search Trees</a></li>
<li class="toc-entry toc-h3"><a href="#segment-tree">Segment Tree</a></li>
<li class="toc-entry toc-h3"><a href="#solving-the-windowing-problem">Solving the Windowing Problem</a></li>
</ul>
</li>
</ul><h2 id="baseline">
<a class="anchor" href="#baseline" aria-hidden="true"><span class="octicon octicon-link"></span></a>Baseline</h2>

<ul>
  <li>
<strong>Real Random Access Machine (RAM) Model</strong> is the basis for algorithmic analysis
    <ul>
      <li>Stored program that has a memory and CPU</li>
      <li>Each memory cell can store a real number; supports all data structures</li>
      <li>Performs basic arithmetic operations (add, subtract, multiply, divide) in O(1) time
        <ul>
          <li>Depending on definition, can also perform more complicated ones like powers or rounding</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="convex-hull">
<a class="anchor" href="#convex-hull" aria-hidden="true"><span class="octicon octicon-link"></span></a>Convex Hull</h2>
<ul>
  <li>
<strong>Convexity</strong>: A shape S is convex if for any two points $p, q \in S$ the line $\bar{pq}$ is covered wholly by the shape</li>
  <li>
<strong>Convex hull</strong>: Any set of points that are convex and contains a set of constraining points</li>
  <li>Problem statement: Given n points, find a convex hull that covers the points</li>
</ul>

<h3 id="line-sweep-algorithm">
<a class="anchor" href="#line-sweep-algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Line Sweep Algorithm</h3>
<ul>
  <li>Stop at event points to form the upper and lower convex hulls separately
    <ul>
      <li>Add points to hull linearly, and if the last three points form an “incorrect turn” (i.e. a left turn for the upper hull, or a right turn for the lower hull), remove offending points</li>
      <li>O(n log n) time; must sort points by x-coordinate first (O(n log n)) and then form the convex hulls linearly (O(n))</li>
      <li>Start with point with the smallest x-coordinate, end with point with largest x-coordinate
        <ul>
          <li>These two are guaranteed to be on the hull</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="gift-wrapping-jarvis-march">
<a class="anchor" href="#gift-wrapping-jarvis-march" aria-hidden="true"><span class="octicon octicon-link"></span></a>Gift Wrapping (Jarvis March)</h3>
<ul>
  <li>Start at lowest point, draw a horizontal line of infinite length</li>
  <li>Look at all points to determine which one will be reached first when rotating the line</li>
  <li>O(hn) runtime, where h is the size of the hull
    <ul>
      <li>Each point on hull requires n comparisons to the other points</li>
    </ul>
  </li>
</ul>

<h3 id="divide-and-conquer">
<a class="anchor" href="#divide-and-conquer" aria-hidden="true"><span class="octicon octicon-link"></span></a>Divide and Conquer</h3>
<ul>
  <li>Separate the set of points S into two sets, S<sub>1</sub> and S<sub>2</sub>
</li>
  <li>Calculate the upper hull for S<sub>1</sub> and S<sub>2</sub>, and then merge them by adding a bridge edge
    <ul>
      <li>No points will lie above this bridge edge, thus keeping the property of the upper hull containing all points</li>
      <li>Can use binary search for a O(log n) merge step</li>
    </ul>
  </li>
</ul>

<h3 id="quick-hull">
<a class="anchor" href="#quick-hull" aria-hidden="true"><span class="octicon octicon-link"></span></a>Quick Hull</h3>
<ul>
  <li>Select the leftmost and rightmost points in S, p and q</li>
  <li>Select the point furthest from $\bar{pq}$, r</li>
  <li>Prune all points in the triangle formed by pqr and call this algorithm on $\bar{pr}$ and $\bar{rq}$</li>
  <li>O(nh) runtime</li>
</ul>

<h3 id="randomized-quickhull">
<a class="anchor" href="#randomized-quickhull" aria-hidden="true"><span class="octicon octicon-link"></span></a>Randomized Quickhull</h3>
<ul>
  <li>Select the leftmost and rightmost points in S, p and r</li>
  <li>Select a random point and shoot a ray perpendicular to $\bar{pr}$</li>
  <li>The bridge edge (AKA edge furthest away from $\bar{pr}$) defined by points s and t will be in the convex hull
    <ul>
      <li>Add s and t to the hull</li>
    </ul>
  </li>
  <li>Call randomized quickhull on $\bar{ps}$ and $\bar{tq}$</li>
  <li>Expected runtime is O(n log h)</li>
</ul>

<h2 id="line-segment-intersections">
<a class="anchor" href="#line-segment-intersections" aria-hidden="true"><span class="octicon octicon-link"></span></a>Line Segment Intersections</h2>
<ul>
  <li>Problem: Given a set S of closed line segments, return all intersections</li>
  <li>Calculating if two lines intersect is O(1); can use matrix operations</li>
  <li>Brute force: O(n<sup>2</sup>); compare all lines with each other</li>
  <li>Run time can be no better than O(n log n + k)
    <ul>
      <li>Element uniqueness problem can be reduced into line segment intersections, and that problem is provably O(n log n)</li>
    </ul>
  </li>
</ul>

<h3 id="plane-sweep-algorithm">
<a class="anchor" href="#plane-sweep-algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Plane Sweep Algorithm</h3>
<ul>
  <li>
<strong>Cleanliness property</strong>: all points to the left of the sweep line have been processed</li>
  <li>
<strong>Sweep Line Status</strong>: store segments that currently intersect with the sweep line in order of their y-coordinate intersections</li>
  <li>Events
    <ul>
      <li>Points in time when sweep line status changes
        <ul>
          <li>e.g. status goes from A, B to B, A</li>
        </ul>
      </li>
      <li>Endpoints of segments</li>
      <li>Intersection points</li>
    </ul>
  </li>
  <li>Event handling
    <ul>
      <li>
<em>Left endpoint</em>: Add segment to sweep line status, check for intersection with adjacent segments, add new intersection point(s) to queue</li>
      <li>
<em>Intersection event</em>: swap order of intersecting segments, check intersections of swapped segments with new adjacencies</li>
      <li>
<em>Right endpoint</em>: delete segment from status, check for intersections in newly adjacent segments</li>
    </ul>
  </li>
  <li>Works by intersection lemma: all intersecting lines must become adjacent at some point</li>
  <li>Runs in O((n + k)log n), where k is the size of the output</li>
</ul>

<h2 id="doubly-connected-edge-list-dcel">
<a class="anchor" href="#doubly-connected-edge-list-dcel" aria-hidden="true"><span class="octicon octicon-link"></span></a>Doubly Connected Edge List (DCEL)</h2>
<ul>
  <li>Representation of a map</li>
  <li>Records each edge, face, and vertex
    <ul>
      <li>Stores geometric information, topological information, attribute information, etc</li>
    </ul>
  </li>
  <li>Used for traversing all faces of a planar intersection, visiting all edges around a given vertex or face</li>
  <li>Main design paradigm: utilizing <strong>half-edges</strong>
    <ul>
      <li>Each edge borders two faces, so use two half-edges to represent one edge with both half-edges going in different directions</li>
      <li>Each face’s half-edges are oriented counter-clockwise, excluding the outer face</li>
    </ul>
  </li>
  <li>Object information
    <ul>
      <li>Vertex stores coordinates, pointer to an incident half-edge that considers the vertex its origin</li>
      <li>Face stores a pointer to one of its half-edges to begin traversal</li>
      <li>Half-edge stores origin vertex, twin half-edge (half-edge that combines with this one to create a single edge), next half-edge on the boundary of the incident face, the previous edge, the face to its left (AKA incident face)</li>
      <li>All of this information can be represented with functions (e.g. IncidentFace(v))</li>
    </ul>
  </li>
  <li>Available operations:
    <ul>
      <li>Walk around the boundary of a given face</li>
      <li>Access a face from an adjacent one</li>
      <li>Visit all edges around a vertex</li>
    </ul>
  </li>
  <li>With n vertices, there are &lt;= 3n-6 edges and &lt;= 2n-4 faces</li>
</ul>

<h3 id="computing-map-overlay">
<a class="anchor" href="#computing-map-overlay" aria-hidden="true"><span class="octicon octicon-link"></span></a>Computing Map Overlay</h3>
<ul>
  <li>Input: Two DCELs; Output: A DCEL that is a combination of both
    <ul>
      <li>Can use the plane sweep line intersection algorithm to construct this DCEL by finding new intersections (vertices)</li>
      <li>Can use some algorithms for boolean operations: union, intersection, difference of DCELs</li>
      <li>Runs in O((n + k)log n), where n is the total size of the two DCELS and k is the number of intersections</li>
    </ul>
  </li>
</ul>

<h2 id="polygon-triangulation-art-gallery-guarding-problem">
<a class="anchor" href="#polygon-triangulation-art-gallery-guarding-problem" aria-hidden="true"><span class="octicon octicon-link"></span></a>Polygon Triangulation (Art Gallery Guarding Problem)</h2>
<ul>
  <li>Given a simple polygon P with n vertices, place a number of guards/cameras on vertices such that every point in P can be seen by some guard/camera</li>
  <li>NP-hard to find minimum number of guards (NP-complete for decision problem)
    <ul>
      <li>
<strong>Simple polygon</strong>: A polygon that does not intersect itself and has no holes</li>
    </ul>
  </li>
  <li>Guard using triagnulations
    <ul>
      <li>
<strong>Triangulate</strong>: Get diagonals between all vertices</li>
      <li>
<strong>Triangulation</strong>: Maximal set of non-crossing diagonals</li>
      <li>Creates many triangles inside the polygon</li>
    </ul>
  </li>
  <li>Simple solution: Place one guard per triangle, either in the middle of it or on a vertex</li>
  <li>
<strong>Theorem</strong>: Every simple polygon has a triangulation with n-2 triangles
    <ul>
      <li>First bound: n-2 guards necessary</li>
    </ul>
  </li>
  <li>3-coloring: assign each vertex a color such that adjacent vertices have different colors
    <ul>
      <li>
<em>Lemma</em>: 3-coloring is possible for vertices in a triangulation
        <ul>
          <li>Create a dual graph: vertex for each triangle, edge between traingles that share an edge</li>
          <li>Max degree of 3 (3 sides), acylcic (tree)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
<strong>Theorem</strong>: You need the floor of n/3 guards to guard the polygon
    <ul>
      <li>Derived from 3-coloring: since each triangle has one of each color, you can choose 1 color and place guards on those vertices</li>
    </ul>
  </li>
</ul>

<h3 id="triangulating-a-polygon">
<a class="anchor" href="#triangulating-a-polygon" aria-hidden="true"><span class="octicon octicon-link"></span></a>Triangulating a Polygon</h3>
<ul>
  <li>O(n log n) algorithm
    <ol>
      <li>Split polygon into monotone polygons, O(n log n)</li>
      <li>Triangulate each monotone polygon, O(n)</li>
    </ol>
  </li>
  <li>A polygon is <strong>monotone</strong> with respect to a line l iff for every line l’ perpendicular to l is connected with P
    <ul>
      <li>x-monotone, y-monotone: monotone with respect to the x or y axis</li>
    </ul>
  </li>
  <li>Can check if triangle is monotone in O(n): check upper and lower half, see if x-coordinates are increasing in values</li>
</ul>

<h4 id="plane-sweep-algorithm-1">
<a class="anchor" href="#plane-sweep-algorithm-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Plane Sweep Algorithm</h4>
<ul>
  <li>Triangulate in O(n) time, with everything to the left of the sweep line being triangulated
    <ul>
      <li>Use left/right turns to determine when to draw triangles</li>
    </ul>
  </li>
</ul>

<h3 id="creating-monotone-polygons">
<a class="anchor" href="#creating-monotone-polygons" aria-hidden="true"><span class="octicon octicon-link"></span></a>Creating Monotone Polygons</h3>
<ul>
  <li>From each vertex, shoot a ray up/down until it hits a boundary
    <ul>
      <li>AKA trapezoidal decomposition</li>
      <li>Takes O(n log n) time to sweep n events, O(log n) time per event bc of binary tree</li>
    </ul>
  </li>
  <li>Identify split/merge vertices as ones with two edges going the same direction</li>
  <li>Add diagonals to each by joining it to the polygon vertex of the trapezoid in the opposite direction of the edges
    <ul>
      <li>Both edges going left = split vertex; both going right = merge vertex</li>
    </ul>
  </li>
</ul>

<h2 id="lower-envelope">
<a class="anchor" href="#lower-envelope" aria-hidden="true"><span class="octicon octicon-link"></span></a>Lower Envelope</h2>
<ul>
  <li>Problem: Given n real-valued functions, find the function f(x) that gives the minimum of all n functions; known as the <strong>lower envelope</strong>
    <ul>
      <li>Other parameters: s is the maximum number of intersection points between any two functions</li>
    </ul>
  </li>
  <li>Assumptions
    <ul>
      <li>All functions are x-monotone</li>
      <li>Function evaluation and intersection finding takes O(1)</li>
      <li>Functions take constant space</li>
    </ul>
  </li>
  <li>Lower envelope represented by list-like object (array, linked list); record the current function being used and the range of x-values for which it’s being used</li>
</ul>

<h3 id="dc-algorithm">
<a class="anchor" href="#dc-algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a>D&amp;C Algorithm</h3>
<ul>
  <li>Divide the set S of n functions in half into S<sub>1</sub> and S<sub>2</sub>
</li>
  <li>Compute the lower envelopes L<sub>1</sub> and L<sub>2</sub> for S<sub>1</sub> and S<sub>2</sub>, respectively</li>
  <li>Use a sweep-line algorithm to merge the lower envelopes</li>
</ul>

<h4 id="sweep-line-merge">
<a class="anchor" href="#sweep-line-merge" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sweep Line Merge</h4>
<ul>
  <li>Event points: All vertices of L<sub>1</sub> and L<sub>2</sub>, all intersection points</li>
  <li>Queue
    <ul>
      <li>Next (right) endpoint of L<sub>1</sub>
</li>
      <li>Next (right) endpoint of L<sub>2</sub>
</li>
      <li>Intersection point (if it exists)</li>
    </ul>
  </li>
  <li>Sweep status: y-order of L<sub>1</sub> and L<sub>2</sub>
</li>
  <li>Runtime is O(λ<sub>s</sub>(n) log n)
    <ul>
      <li>λ<sub>s</sub> has an upper bound of n log* n</li>
      <li>log* n is defined as the number of times you have to log a number for it to be less than 1</li>
    </ul>
  </li>
  <li>Inverse Ackermann function: slowest growing function possible
    <ul>
      <li>λ<sub>3</sub>(n) has an average runtime of n * α(n), where α(n) is the Inverse Ackermann function</li>
    </ul>
  </li>
</ul>

<h2 id="linear-programming">
<a class="anchor" href="#linear-programming" aria-hidden="true"><span class="octicon octicon-link"></span></a>Linear Programming</h2>

<ul>
  <li>Problem: Optimize an objective function subject to some constraints</li>
  <li>
<strong>Linear program</strong>: Defined by d variables and n constraints</li>
  <li>Each constraint can be considered a half-space in R<sup>d</sup>; e.g. the 2D case with lines</li>
  <li>The set of points satisfying all constraints is $\cap_{i=1}^{n} h_i$</li>
  <li>Want to maximize $f_{\vec{c}} = \vec{x} \cdot \vec{c}$, i.e. finding a point $\vec{x}$ that is extreme in the direction of $\vec{c}$</li>
</ul>

<h3 id="half-plane-intersection">
<a class="anchor" href="#half-plane-intersection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Half-Plane Intersection</h3>
<ul>
  <li>Given a set of n half-planes in 2D, return the set of points in the interesction of the set
    <ul>
      <li>The output will be a convex polygon with at most n edges</li>
    </ul>
  </li>
  <li>Can use the same method employed in the lower envelope algorithm; divide and conquer
    <ul>
      <li>O(n log n) runtime</li>
    </ul>
  </li>
</ul>

<h3 id="incremental-linear-programming">
<a class="anchor" href="#incremental-linear-programming" aria-hidden="true"><span class="octicon octicon-link"></span></a>Incremental Linear Programming</h3>
<ul>
  <li>Assumes that the linear program is bounded and that there’s a unique solution</li>
  <li>Add half-planes one by one and keep track of the optimal solution</li>
  <li>Definitions: $H_i = [h_1, h_2, …, h_3], C_n = \cap_{i=1}^{n} h_i, v_i = \text{ Optimal vertex for } C_i$</li>
  <li>Lemma
    <ul>
      <li>If $v_{i-1} \in h_i$, then $v_i = v_{i-1}$</li>
      <li>If $v_{i-1} \notin h_i$, then $C_i = \emptyset$ or $v_i \in l_i$, the line bounding $h_i$</li>
    </ul>
  </li>
  <li>Takes O(n<sup>2</sup>) time in worst case because of the case where $v_{i-1} \notin h_i$</li>
  <li>Takes O(n) time on average when randomizing the input</li>
</ul>

<h3 id="seidels-algorithm">
<a class="anchor" href="#seidels-algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Seidel’s Algorithm</h3>
<ul>
  <li>Randomly permute constraints</li>
  <li>Choose an infinity for an optimal solution</li>
  <li>For each constraint:
    <ul>
      <li>Check if solution point obeys new constraint</li>
      <li>If not, solve the new constraint’s (d-1)-dimensional linear program recursively and update optimal solution</li>
    </ul>
  </li>
  <li>Exepected runtime is O(d!n) which is O(n) in lower dimensions</li>
</ul>

<h2 id="orthogonal-range-searching">
<a class="anchor" href="#orthogonal-range-searching" aria-hidden="true"><span class="octicon octicon-link"></span></a>Orthogonal Range Searching</h2>

<ul>
  <li>Given n points in d dimensions, query an axis algined box
    <ul>
      <li>Can report points in box, the number inside the box, etc.</li>
      <li>Goal: preprocess this list into a data structure that supports fast queries</li>
    </ul>
  </li>
</ul>

<h3 id="1d-case">
<a class="anchor" href="#1d-case" aria-hidden="true"><span class="octicon octicon-link"></span></a>1D Case</h3>

<ul>
  <li>Naive: store points in an array and query by binary searching on endpoints
    <ul>
      <li>O(k + log n) runtime to list all points in query</li>
    </ul>
  </li>
  <li>Better: use a balanced binary search tree
    <ul>
      <li>Store points in the leaves of tree</li>
      <li>Internal nodes store copies of leaves for binary search</li>
      <li>key[x] is the maximum key of any leaf in the left subtree</li>
      <li>Faster than binary searching because you can “share” the two binary search queries up until a split node</li>
      <li>Can make counting queries (i.e. how many points lie in this range) faster by storing number of nodes in subtree for each node</li>
    </ul>
  </li>
  <li>BST: Space is O(n), preprocessing is O(n log n)</li>
</ul>

<h3 id="naive-2d-case">
<a class="anchor" href="#naive-2d-case" aria-hidden="true"><span class="octicon octicon-link"></span></a>Naive 2D Case</h3>

<ul>
  <li>Create a 1D binary tree for x-coordinates, and for every node, store another 1D tree for y-coordinates</li>
  <li>Query both trees to find all points</li>
  <li>Query time: $O(log^2n)$ or $O(k + log^2n)$ for reporting list of points</li>
  <li>Preprocessing: $O(n log n)$</li>
  <li>Space: O(n log n)</li>
</ul>

<h3 id="better-2d-fractional-cascading">
<a class="anchor" href="#better-2d-fractional-cascading" aria-hidden="true"><span class="octicon octicon-link"></span></a>Better 2D: Fractional Cascading</h3>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Fractional_cascading">Wikipedia link</a></li>
  <li>Results in O(log n) for counting queries or O(k + log n) for listing queries</li>
</ul>

<h3 id="d-dimension-case">
<a class="anchor" href="#d-dimension-case" aria-hidden="true"><span class="octicon octicon-link"></span></a>d-Dimension Case</h3>

<ul>
  <li>For each node in the d-dimension tree, add a tree for the (d-1)-dimension</li>
  <li>In the 2D case, use fractional cascading</li>
  <li>Query time is $O(log^{d-1}n)$ or $O(log^{d-1}n + k)$ depending on query type
    <ul>
      <li>log factor is saved by fractional cascading; without it would be $O(log^d n)$</li>
    </ul>
  </li>
  <li>Preprocessing: $O(n log^{d-1} n)$</li>
  <li>Space: $O(log^{d-1}n)$</li>
</ul>

<h3 id="kd-tree">
<a class="anchor" href="#kd-tree" aria-hidden="true"><span class="octicon octicon-link"></span></a>KD tree</h3>

<ul>
  <li>Split odd layers by x-coordinate and even layers by y-coordinate in the 2D case
    <ul>
      <li>Higher dimensions will use modulo to determine which coordinate to discriminate on</li>
    </ul>
  </li>
  <li>Similar to a decision tree</li>
  <li>O(n log n) preprocessing time</li>
  <li>$O(n^{1 - \frac{1}{d}})$ or $O(n^{1 - \frac{1}{d}} + k)$ query time</li>
</ul>

<h2 id="point-location">
<a class="anchor" href="#point-location" aria-hidden="true"><span class="octicon octicon-link"></span></a>Point Location</h2>

<ul>
  <li>An undirected graph is considered <strong>planar</strong> if it can be embedded in the plane without edge crossings</li>
  <li>A planar embedding induces a planar subdivision; represented by DCEL
    <ul>
      <li>Edges, faces, and vertices are all linear compared to each other; O(n)</li>
    </ul>
  </li>
  <li>Problem: Given a planar subdivision, find which face a point p lies in
    <ul>
      <li>Naive: Use DCEL to check each face in O(n) time</li>
    </ul>
  </li>
</ul>

<h3 id="slab-method">
<a class="anchor" href="#slab-method" aria-hidden="true"><span class="octicon octicon-link"></span></a>Slab Method</h3>

<ul>
  <li>Draw a vertical line through each point, dividing the subdivision into “slabs”</li>
  <li>Binary search for the slab p lies in and binary search the slab to determine the face</li>
  <li>$O(n^2 log n)$ preprocessing, $O(n^2)$ space, $O(log n)$ query</li>
</ul>

<h3 id="plane-sweep">
<a class="anchor" href="#plane-sweep" aria-hidden="true"><span class="octicon octicon-link"></span></a>Plane Sweep</h3>

<ul>
  <li>Events: Intersections and endpoints</li>
  <li>Status: Ordering of lines, lines are removed/added/reordered based on events</li>
  <li>Runtime is O(n log n), can be used to preprocess the DCEL</li>
  <li>
<em>Persistent</em> data structures allow for queries on past versions of themselves
    <ul>
      <li>BSTs do this via path copying; never overwrite old nodes, simply create new copies</li>
    </ul>
  </li>
  <li>Path copying for persistence maintains the O(n log n) runtime but extends space to O(n log n)
    <ul>
      <li>
<strong>Fat nodes</strong>, as defined in the Sarnak and Tarjan paper, reduce space to O(n)</li>
    </ul>
  </li>
  <li>Point location is done in O(log n)</li>
</ul>

<h3 id="kirkpatricks-point-location-algorithm">
<a class="anchor" href="#kirkpatricks-point-location-algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kirkpatrick’s Point Location Algorithm</h3>

<ul>
  <li>Takes traingulation as input</li>
  <li>Can convert a planar subdivision to a triangulation in linear time
    <ul>
      <li>Triangulate each face, maintaining label, in O(n) time</li>
      <li>Turn outer face into triangle by drawing a triangle around the convex hull</li>
    </ul>
  </li>
  <li>Size is O(n), conversion is O(n)</li>
</ul>

<h4 id="kirkpatricks-hierarchy">
<a class="anchor" href="#kirkpatricks-hierarchy" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kirkpatrick’s Hierarchy</h4>
<ul>
  <li>Compute a sequence $T_0, …, T_k$ of increasingly coarse triangulations</li>
  <li>$T_0$ is the input triangulation, $T_k$ is the outer triangle</li>
  <li>k is O(log n) and each triangle in $T_{i+1}$ intersects a constant number of triangles in $T_i$</li>
  <li>Build this sequence by deleting vertices and re-triangulating
    <ul>
      <li>Delete a constant fraction of vertices O(log n) times</li>
      <li>Only delete vertices with a constant degree (≤8)</li>
      <li>Choose an independent set of vertices to delete; don’t delete adjacent ones</li>
      <li>O(n) run time</li>
      <li>Removes n/18 vertices each time; $log_{18/17} n$ steps</li>
    </ul>
  </li>
  <li>Query: Store hierarchy as DAG (or tree) and path find to the corresponding triangle in $T_0$</li>
  <li>Complete algorithm has O(n) preprocessing, O(n) space, and O(log n) query but with large constant factors
    <ul>
      <li>O(216 log n), O(18n)</li>
    </ul>
  </li>
</ul>

<h2 id="voronoi-diagrams">
<a class="anchor" href="#voronoi-diagrams" aria-hidden="true"><span class="octicon octicon-link"></span></a>Voronoi Diagrams</h2>

<ul>
  <li>Given a set of point sites $P = {p_1, …, p_n} \in \R^2$</li>
  <li>
<strong>Voronoi cell</strong>: $V(p_i) = {q \in \R^2 \vert d(p_i, q) &lt; d(p_j, q) \text{ for all } j \neq i}$</li>
  <li>
<strong>Voronoi diagram</strong>: The planar division derived from removing all V cells</li>
  <li>
<strong>Voronoi edges</strong> are bisectors of points; equidistant from two points p and q</li>
  <li>
<strong>Voronoi vertex</strong>: the intersection of three edges
    <ul>
      <li>Guaranteed to be the center of an empty disk defined by three sites</li>
    </ul>
  </li>
  <li>Voronoi cells are convex, as they are the intersection of half planes
    <ul>
      <li>Cells have at most n-1 cells</li>
    </ul>
  </li>
  <li>Number of vertices ≤ 2n - 5, Number of edges ≤ 3n - 6</li>
  <li>A Voronoi cell $V(p_i)$ will be unbounded if and only if $p_i$ is on the convex hull of P</li>
  <li>Can use non-Euclidean distance formulas</li>
</ul>

<h3 id="fortunes-sweep">
<a class="anchor" href="#fortunes-sweep" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fortune’s Sweep</h3>

<ul>
  <li>Status: “beach line”
    <ul>
      <li>Can be thought of as the lower envelope of parabolas above the sweep line
        <ul>
          <li>Parabolas are equidistant from their origin site and line</li>
        </ul>
      </li>
      <li>Intersections of parabolas will be on a Voronoi edge</li>
    </ul>
  </li>
  <li>Events
    <ul>
      <li>New point (<strong>Site Event</strong>)
        <ul>
          <li>A new parabola must be drawn for the new point</li>
          <li>Create a new Voronoi edge by tracing the intersection of parabolas</li>
        </ul>
      </li>
      <li>
<strong>Circle Event</strong>
        <ul>
          <li>An arc shrinks to a point and disappears; “eaten up” by two other parabolas</li>
          <li>Defines a Voronoi vertex</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Voronoi diagram will be stored in a DCEL</li>
  <li>Status will be stores in a BST
    <ul>
      <li>The tree’s leaves store sitres that define the arcs above the beach line</li>
      <li>Internal nodes refer to break points; intersections of arcs</li>
    </ul>
  </li>
  <li>Event queue: Priority queue ordered by y-coordinate
    <ul>
      <li>New sites are stored as site events</li>
      <li>Circle events
        <ul>
          <li>Store lowest point of circle</li>
          <li>Store pointer to the leaf/arc in the tree that will disappear</li>
        </ul>
      </li>
      <li>Size: O(n) because there are n sites and O(n) circles</li>
    </ul>
  </li>
  <li>Detecting circle events
    <ul>
      <li>Store the circles created by any three consecutive points</li>
      <li>Calculate point on circle</li>
    </ul>
  </li>
  <li>Handling site events
    <ul>
      <li>Locate parabola directly above new point</li>
      <li>If a circle event related to the parabola exists, delete it</li>
      <li>Replace the prior leaf node corresponding to the above parabola with a three-subtree containing the new point’s leaf node in the middle and leaf nodes for the old point on the outside</li>
      <li>Add new half-edges separated by the new breakpoints to the DCEL</li>
      <li>Create new circle events with the newly consecutive points and add them if they are below the sweep line</li>
    </ul>
  </li>
  <li>Handling circle events
    <ul>
      <li>Delete the point corresponding to the disappearing arc</li>
      <li>Add intersection point to Voronoi diagram and add half-edges for the breakpoints</li>
      <li>Check newly consecutive parabolas for circle events</li>
    </ul>
  </li>
  <li>Total runtime: O(n log n)
    <ul>
      <li>Insert and delete is O(log n), O(n) events</li>
    </ul>
  </li>
</ul>

<h2 id="point-line-duality">
<a class="anchor" href="#point-line-duality" aria-hidden="true"><span class="octicon octicon-link"></span></a>Point Line Duality</h2>
<ul>
  <li>Let $P = {p_1, …, p_n} \in \R ^2$ be a set of points</li>
  <li>$P* = {p_1^<em>, …, p_n^</em>}$ is defined as the <em>dual</em> set of lines
    <ul>
      <li>Primal: Point p: (p<sub>x</sub>, p<sub>y</sub>), Line l: y = mx + b</li>
      <li>Dual: Line p* = y = p<sub>x</sub>x - p<sub>y</sub>, Point l* = (m, -b)</li>
    </ul>
  </li>
  <li>Properties
    <ul>
      <li>(p<em>)</em> = p</li>
      <li>$p \in l \iff l^* \in p^*$ (Incidence preservation)</li>
      <li>$\text{p lies above l} \iff l^* \text{ lies above } p^*$ (Order preservation)</li>
    </ul>
  </li>
  <li>From the properties, it follows that the intersection of lines in the dual plane defines the line between two points in the primal plane</li>
  <li>Used for mapping algorithms between planes
    <ul>
      <li>e.g. the lower convex hull in primal is the same as the upper envelope in dual</li>
    </ul>
  </li>
  <li>Conversion takes O(n) time</li>
</ul>

<h2 id="line-arrangements">
<a class="anchor" href="#line-arrangements" aria-hidden="true"><span class="octicon octicon-link"></span></a>Line Arrangements</h2>
<ul>
  <li>Let L be a set of lines; then, A(L) is the <strong>arrangement</strong> of L
    <ul>
      <li>Defined as the planar subdivision induced by all lines in L; represented by DCEL</li>
    </ul>
  </li>
  <li>Vertices &lt;= n choose 2 (O(n<sup>2</sup>)), edges &lt;= n<sup>2</sup>, faces &lt;= 1 + n(n+1)/2</li>
  <li>Using a sweep line algorithm would take O(n<sup>2</sup> log n) time</li>
  <li>Incremental construction takes this down to O(n<sup>2</sup>)
    <ul>
      <li>Add lines one at a time</li>
      <li>Each line is guaranteed to intersect/split O(i) faces by the Zone Theorem</li>
      <li>O(i) &lt; O(n)</li>
    </ul>
  </li>
</ul>

<h2 id="delaunay-triangulation">
<a class="anchor" href="#delaunay-triangulation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Delaunay Triangulation</h2>
<ul>
  <li>The triangulation of a set of point is guaranteed to have an outer face bounded by the convex hull</li>
  <li>The dual graph G* has a node for each face of G and an edge connecting nodes if and only if the faces share an edge
    <ul>
      <li>G would be a planar subdivision</li>
    </ul>
  </li>
  <li>The <strong>Delaunay triangulation</strong> is the dual graph of a Voronoi diagram for a set of points
    <ul>
      <li>Making each edge straight in the Delaunay triangulation turns it into a triangulation</li>
      <li>Only occurs if P is in general position</li>
      <li>Can be stored as an abstract graph; less space than a DCEL</li>
    </ul>
  </li>
  <li>Straight line edges don’t intersect due to the fact that an edge exists in the Delaunay graph if and only if an empty disk exists that has both points on its boundary</li>
  <li>For any three points in P:
    <ul>
      <li>Their triangle is in the Delaunay triangulation</li>
      <li>The center of the circle is a vertex in the Voronoi diagram</li>
      <li>Equivalent statements</li>
    </ul>
  </li>
  <li>Can be used to compute the convex hull of a 3D set of points</li>
</ul>

<h2 id="3d-convex-hull">
<a class="anchor" href="#3d-convex-hull" aria-hidden="true"><span class="octicon octicon-link"></span></a>3D Convex Hull</h2>

<h3 id="gift-wrapping">
<a class="anchor" href="#gift-wrapping" aria-hidden="true"><span class="octicon octicon-link"></span></a>Gift Wrapping</h3>
<ol>
  <li>Find a face guaranteed to be on the convex hull</li>
  <li>Choose an edge on this face whose other face has not been found</li>
  <li>Find the point that creates the minimum angle with the current face and add it to the convex hull
    <ul>
      <li>Note that the new point creates a triangle when joined with the original edge
    - Runtime is O(nF) where F is the number of faces</li>
    </ul>
  </li>
</ol>

<h3 id="divide-and-conquer-1">
<a class="anchor" href="#divide-and-conquer-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Divide and Conquer</h3>
<ul>
  <li>Same paradigm as 2D; divide points into two sets and merge the calculated convex hulls</li>
  <li>Merge step
    <ul>
      <li>Option 1: Find each new face by projecting the set of points into 2D and finding the new hull using the same 2D binary search method</li>
      <li>Option 2: Find the bottom plane that merges the two hulls, and gift wrap it around
        <ul>
          <li>Since you can ignore points if they don’t belong on the hull when processed, this takes O(n) time</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Runtime: O(n log n)</li>
</ul>

<h2 id="windowing">
<a class="anchor" href="#windowing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Windowing</h2>

<ul>
  <li>Input: A set S of line segments</li>
  <li>Query: Report all segments that intersect a query window</li>
  <li>Subproblem (1D): Report all intervals that contain a query point</li>
</ul>

<h3 id="interval-trees">
<a class="anchor" href="#interval-trees" aria-hidden="true"><span class="octicon octicon-link"></span></a>Interval Trees</h3>
<ul>
  <li>Input: A set of I intervals on a line</li>
  <li>Uses D&amp;C paradigm: Partition I at each step into I<sub>left</sub>, I<sub>mid</sub>, and I<sub>right</sub>
    <ul>
      <li>I<sub>mid</sub> contains intervals containing the median of the 2n endpoints</li>
      <li>I<sub>mid</sub> stores intervals in two lists; one sorted by left endpoint, and one stored by right endpoint</li>
    </ul>
  </li>
  <li>O(n) space (each interval stored in two lists), O(n log n) preprocessing (Master’s theorem), O(log n + k) query
    <ul>
      <li>Each node takes O(1 + k<sub>v</sub>) time, as we must report the k<sub>v</sub> intervals hit at each node</li>
    </ul>
  </li>
</ul>

<h3 id="priority-search-trees">
<a class="anchor" href="#priority-search-trees" aria-hidden="true"><span class="octicon octicon-link"></span></a>Priority Search Trees</h3>
<ul>
  <li>Allows for 3-sided range queries; find all points in a range where one of the sides is unbounded
    <ul>
      <li>e.g. two y constraints and one x constraint</li>
    </ul>
  </li>
  <li>Acts like a heap on x and a BST on y</li>
  <li>Each vertex stores the minimum x-coordinate of its set of points and the median y-coordinate
    <ul>
      <li>For children nodes: split the set of points by median y-coordinate, and then intialize them with the point with the minimum x-coordinate</li>
    </ul>
  </li>
  <li>O(log n + k) 3-sided query, O(n) space, built in O(n log n)</li>
</ul>

<h3 id="segment-tree">
<a class="anchor" href="#segment-tree" aria-hidden="true"><span class="octicon octicon-link"></span></a>Segment Tree</h3>
<ul>
  <li>Partition line segments by all endpoints
    <ul>
      <li>$\text{Line segments} = {(-\infty, p_1), [p_1, p_1], (p_1, p_2), …, (p_n , \infty)}$</li>
    </ul>
  </li>
  <li>Store intervals in leaves of tree
    <ul>
      <li>Parent nodes are unions of their children’s intervals</li>
    </ul>
  </li>
  <li>O(n) space; each interval can be stored in a maximum of two nodes</li>
  <li>O(log n + k) query, O(n log n) preprocess</li>
  <li>Built bottom up from the leaf nodes</li>
</ul>

<h3 id="solving-the-windowing-problem">
<a class="anchor" href="#solving-the-windowing-problem" aria-hidden="true"><span class="octicon octicon-link"></span></a>Solving the Windowing Problem</h3>
<ul>
  <li>Create slabs using the segment tree and search for the slabs contained by the query</li>
  <li>In each slab, use a 1D range query (taken from point location) to detect segments that intersect</li>
  <li>O(log<sup>2</sup> n + k) query; query the segment tree in O(log n) time, and for each of those queries, query the 1D range tree in O(log n) time</li>
  <li>O(n log n) preprocessing</li>
  <li>O(n log n) space because each node contains a 1D range tree</li>
</ul>

  </div><a class="u-url" href="/college-notes/cs164/lecture/fall24/markdown/2024/09/26/cs-164-lecture.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/college-notes/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="https://tonyhieu.github.io/college-notes/feed.xml">
            <svg class="svg-icon orange">
              <path d="M12.8 16C12.8 8.978 7.022 3.2 0 3.2V0c8.777 0 16 7.223 16 16h-3.2zM2.194
                11.61c1.21 0 2.195.985 2.195 2.196 0 1.21-.99 2.194-2.2 2.194C.98 16 0 15.017 0
                13.806c0-1.21.983-2.195 2.194-2.195zM10.606
                16h-3.11c0-4.113-3.383-7.497-7.496-7.497v-3.11c5.818 0 10.606 4.79 10.606 10.607z"
              />
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>Site to document notes for various classes</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li>
    <a rel="me" href="" target="_blank" title="">
      <span class="grey fa-brands fa- fa-lg"></span>
    </a>
  </li><li>
    <a rel="me" href="" target="_blank" title="">
      <span class="grey fa-brands fa- fa-lg"></span>
    </a>
  </li></ul>
</div>

  </div>

</footer>

</body>

</html>
