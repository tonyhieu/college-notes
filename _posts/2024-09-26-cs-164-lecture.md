---
layout: post
description: COMPSCI 164
categories: [cs164, lecture, fall24, markdown]
title: Computational Geometry
use-math: true
toc: true
---

## Baseline

- **Real Random Access Machine (RAM) Model** is the basis for algorithmic analysis
    - Stored program that has a memory and CPU
    - Each memory cell can store a real number; supports all data structures
    - Performs basic arithmetic operations (add, subtract, multiply, divide) in O(1) time
        - Depending on definition, can also perform more complicated ones like powers or rounding

## Convex Hull
- **Convexity**: A shape S is convex if for any two points $p, q \in S$ the line $\bar{pq}$ is covered wholly by the shape
- **Convex hull**: Any set of points that are convex and contains a set of constraining points
- Problem statement: Given n points, find a convex hull that covers the points

### Line Sweep Algorithm
- Stop at event points to form the upper and lower convex hulls separately
    - Add points to hull linearly, and if the last three points form an "incorrect turn" (i.e. a left turn for the upper hull, or a right turn for the lower hull), remove offending points
    - O(n log n) time; must sort points by x-coordinate first (O(n log n)) and then form the convex hulls linearly (O(n))
    - Start with point with the smallest x-coordinate, end with point with largest x-coordinate
        - These two are guaranteed to be on the hull

### Gift Wrapping (Jarvis March)
- Start at lowest point, draw a horizontal line of infinite length
- Look at all points to determine which one will be reached first when rotating the line
- O(hn) runtime, where h is the size of the hull
    - Each point on hull requires n comparisons to the other points

### Divide and Conquer
- Separate the set of points S into two sets, S<sub>1</sub> and S<sub>2</sub>
- Calculate the upper hull for S<sub>1</sub> and S<sub>2</sub>, and then merge them by adding a bridge edge
    - No points will lie above this bridge edge, thus keeping the property of the upper hull containing all points
    - Can use binary search for a O(log n) merge step

## Line Segment Intersections
- Problem: Given a set S of closed line segments, return all intersections
- Calculating if two lines intersect is O(1); can use matrix operations
- Brute force: O(n<sup>2</sup>); compare all lines with each other
- Run time can be no better than O(n log n + k)
    - Element uniqueness problem can be reduced into line segment intersections, and that problem is provably O(n log n)

### Plane Sweep Algorithm
- **Cleanliness property**: all points to the left of the sweep line have been processed
- **Sweep Line Status**: store segments that currently intersect with the sweep line in order of their y-coordinate intersections
- Events
    - Points in time when sweep line status changes
        - e.g. status goes from A, B to B, A
    - Endpoints of segments
    - Intersection points
- Event handling
    - *Left endpoint*: Add segment to sweep line status, check for intersection with adjacent segments, add new intersection point(s) to queue
    - *Intersection event*: swap order of intersecting segments, check intersections of swapped segments with new adjacencies
    - *Right endpoint*: delete segment from status, check for intersections in newly adjacent segments
- Works by intersection lemma: all intersecting lines must become adjacent at some point

## Doubly Connected Edge List (DCEL)
- Representation of a map
- Records each edge, face, and vertex
    - Stores geometric information, topological information, attribute information, etc
- Used for traversing all faces of a planar intersection, visiting all edges around a given vertex or face
- Main design paradigm: utilizing **half-edges**
    - Each edge borders two faces, so use two half-edges to represent one edge with both half-edges going in different directions
    - Each face's half-edges are oriented counter-clockwise, excluding the outer face
- Object information
    - Vertex stores coordinates, pointer to an incident half-edge that considers the vertex its origin
    - Face stores a pointer to one of its half-edges to begin traversal
    - Half-edge stores origin vertex, twin half-edge (half-edge that combines with this one to create a single edge), next half-edge on the boundary of the incident face, the previous edge, the face to its left (AKA incident face)
    - All of this information can be represented with functions (e.g. IncidentFace(v))
- Available operations:
    - Walk around the boundary of a given face
    - Access a face from an adjacent one
    - Visit all edges around a vertex
- With n vertices, there are <= 3n-6 edges and <= 2n-4 faces

### Computing Map Overaly
- Input: Two DCELs; Output: A DCEL that is a combination of both
    - Can use the plane sweep line intersection algorithm to construct this DCEL by finding new intersections (vertices)
    - Can use some algorithms for boolean operations: union, intersection, difference of DCELs

## Polygon Triangulation (Art Gallery Guarding Problem)
- Given a simple polygon P with n vertices, place a number of guards/cameras on vertices such that every point in P can be seen by some guard/camera
- NP-hard to find minimum number of guards (NP-complete for decision problem)
- Guard using triagnulations
    - **Triangulate**: Get diagonals between all vertices
    - **Triangulation**: Maximal set of non-crossing diagonals
    - Creates many triangles inside the polygon
- Simple solution: Place one guard per triangle, either in the middle of it or on a vertex
- **Theorem**: Every simple polygon has a triangulation with n-2 triangles
    - First bound: n-2 guards necessary
- 3-coloring: assign each vertex a color such that adjacent vertices have different colors
    - *Lemma*: 3-coloring is possible for vertices in a triangulation
        - Create a dual graph: vertex for each triangle, edge between traingles that share an edge
        - Max degree of 3 (3 sides), acylcic (tree)
- **Theorem**: You need the floor of n/3 guards to guard the polygon
    - Derived from 3-coloring: since each triangle has one of each color, you can choose 1 color and place guards on those vertices

### Triangulating a Polygon
- O(n log n) algorithm
    1. Split polygon into monotone polygons, O(n log n)
    2. Triangulate each monotone polygon, O(n)
- A polygon is **monotone** with respect to a line l iff for every line l' perpendicular to l is connected with P
    - x-monotone, y-monotone: monotone with respect to the x or y axis
- Can check if triangle is monotone in O(n): check upper and lower half, see if x-coordinates are increasing in values

#### Plane Sweep Algorithm
- Triangulate in O(n) time, with everything to the left of the sweep line being triangulated
    - Use left/right turns to determine when to draw triangles

### Creating Monotone Polygons
- From each vertex, shoot a ray up/down until it hits a boundary
    - AKA trapezoidal decomposition
    - Takes O(n log n) time to sweep n events, O(log n) time per event bc of binary tree
- Identify split/merge vertices as ones with two edges going the same direction
- Add diagonals to each by joining it to the polygon vertex of the trapezoid in the opposite direction of the edges
    - Both edges going left = split vertex; both going right = merge vertex

## Lower Envelope
- Problem: Given n real-valued functions, find the function f(x) that gives the minimum of all n functions; known as the **lower envelope**
    - Other parameters: s is the maximum number of intersection points between any two functions
- Assumptions
    - All functions are x-monotone
    - Function evaluation and intersection finding takes O(1)
    - Functions take constant space
- Lower envelope represented by list-like object (array, linked list); record the current function being used and the range of x-values for which it's being used

### D&C Algorithm
- Divide the set S of n functions in half into S<sub>1</sub> and S<sub>2</sub>
- Compute the lower envelopes L<sub>1</sub> and L<sub>2</sub> for S<sub>1</sub> and S<sub>2</sub>, respectively
- Use a sweep-line algorithm to merge the lower envelopes

#### Sweep Line Merge
- Event points: All vertices of L<sub>1</sub> and L<sub>2</sub>, all intersection points
- Queue
    - Next (right) endpoint of L<sub>1</sub> 
    - Next (right) endpoint of L<sub>2</sub> 
    - Intersection point (if it exists)
- Sweep status: y-order of L<sub>1</sub> and L<sub>2</sub>
- Runtime is O(λ<sub>s</sub>(n) log n)
    - λ<sub>s</sub> has an upper bound of n log* n
    - log* n is defined as the number of times you have to log a number for it to be less than 1
- Inverse Ackermann function: slowest growing function possible
    - λ<sub>3</sub>(n) has an average runtime of n * α(n), where α(n) is the Inverse Ackermann function