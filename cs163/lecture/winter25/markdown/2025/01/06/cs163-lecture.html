<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Graph Algorithms | Anthony Vo’s College Notes</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Graph Algorithms" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="COMPSCI 163" />
<meta property="og:description" content="COMPSCI 163" />
<link rel="canonical" href="https://tonyhieu.github.io/college-notes/cs163/lecture/winter25/markdown/2025/01/06/cs163-lecture.html" />
<meta property="og:url" content="https://tonyhieu.github.io/college-notes/cs163/lecture/winter25/markdown/2025/01/06/cs163-lecture.html" />
<meta property="og:site_name" content="Anthony Vo’s College Notes" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-01-06T00:00:00-06:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Graph Algorithms" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-01-06T00:00:00-06:00","datePublished":"2025-01-06T00:00:00-06:00","description":"COMPSCI 163","headline":"Graph Algorithms","mainEntityOfPage":{"@type":"WebPage","@id":"https://tonyhieu.github.io/college-notes/cs163/lecture/winter25/markdown/2025/01/06/cs163-lecture.html"},"url":"https://tonyhieu.github.io/college-notes/cs163/lecture/winter25/markdown/2025/01/06/cs163-lecture.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/college-notes/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://tonyhieu.github.io/college-notes/feed.xml" title="Anthony Vo's College Notes" /><link rel="shortcut icon" type="image/x-icon" href="/college-notes/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/college-notes/">Anthony Vo&#39;s College Notes</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/college-notes/schedule/">Class Schedule</a><a class="page-link" href="/college-notes/labs/">Labs</a><a class="page-link" href="/college-notes/categories/">Tags</a><a class="page-link" href="/college-notes/search/">Search</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Graph Algorithms</h1><p class="page-description">COMPSCI 163</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2025-01-06T00:00:00-06:00" itemprop="datePublished">
        Jan 6, 2025
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      27 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/college-notes/categories/#cs163">cs163</a>
        &nbsp;
      
        <a class="category-tags-link" href="/college-notes/categories/#lecture">lecture</a>
        &nbsp;
      
        <a class="category-tags-link" href="/college-notes/categories/#winter25">winter25</a>
        &nbsp;
      
        <a class="category-tags-link" href="/college-notes/categories/#markdown">markdown</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#graph-representation">Graph Representation</a>
<ul>
<li class="toc-entry toc-h3"><a href="#decorator-pattern-and-adjacency-lists">Decorator Pattern and Adjacency Lists</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#bfsdfs">BFS/DFS</a></li>
<li class="toc-entry toc-h2"><a href="#minimum-spanning-trees">Minimum Spanning Trees</a>
<ul>
<li class="toc-entry toc-h3"><a href="#applications">Applications</a></li>
<li class="toc-entry toc-h3"><a href="#properties">Properties</a></li>
<li class="toc-entry toc-h3"><a href="#algorithms">Algorithms</a>
<ul>
<li class="toc-entry toc-h4"><a href="#jarniks-algorithm-prim-dijkstra">Jarnik’s Algorithm (Prim-Dijkstra)</a></li>
<li class="toc-entry toc-h4"><a href="#kruskals-algorithm">Kruskal’s Algorithm</a></li>
<li class="toc-entry toc-h4"><a href="#boruvkas-algorithm-sollin">Boruvka’s Algorithm (Sollin)</a></li>
<li class="toc-entry toc-h4"><a href="#hybrid-algorithm">Hybrid Algorithm</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#topological-ordering">Topological Ordering</a></li>
<li class="toc-entry toc-h2"><a href="#shortest-and-longest-paths">Shortest and Longest Paths</a>
<ul>
<li class="toc-entry toc-h3"><a href="#critical-path-scheduling-pert-method">Critical Path Scheduling (PERT method)</a></li>
<li class="toc-entry toc-h3"><a href="#shortest-path-trees-and-relaxation-algorithms">Shortest Path Trees and Relaxation Algorithms</a>
<ul>
<li class="toc-entry toc-h4"><a href="#bellman-ford-algorithm">Bellman-Ford Algorithm</a></li>
<li class="toc-entry toc-h4"><a href="#dijkstras-algorithm">Dijkstra’s Algorithm</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#changing-weights-without-changing-optimum-paths">Changing Weights without Changing Optimum Paths</a>
<ul>
<li class="toc-entry toc-h4"><a href="#johnsons-algorithm">Johnson’s Algorithm</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#suurballes-algorithm">Suurballe’s Algorithm</a></li>
<li class="toc-entry toc-h3"><a href="#a">A*</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#widest-paths">Widest Paths</a>
<ul>
<li class="toc-entry toc-h3"><a href="#linear-algorithm">Linear Algorithm</a></li>
<li class="toc-entry toc-h3"><a href="#dijkstra">Dijkstra</a>
<ul>
<li class="toc-entry toc-h4"><a href="#all-pairs-directed-widest-paths">All-Pairs Directed Widest Paths</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#applications-voting-systems">Applications: Voting Systems</a>
<ul>
<li class="toc-entry toc-h4"><a href="#condorcet-property--schulze-method">Condorcet Property / Schulze Method</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#euler-tours">Euler Tours</a>
<ul>
<li class="toc-entry toc-h3"><a href="#fleurys-algortihm">Fleury’s Algortihm</a></li>
<li class="toc-entry toc-h3"><a href="#hierholzers-algorithm">Hierholzer’s Algorithm</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#traveling-salesman-problem">Traveling Salesman Problem</a>
<ul>
<li class="toc-entry toc-h3"><a href="#2-approximation">2-Approximation</a></li>
<li class="toc-entry toc-h3"><a href="#32-approximation">3/2-Approximation</a></li>
<li class="toc-entry toc-h3"><a href="#exact-dp-algorithm">Exact DP Algorithm</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#cliques-and-coloring">Cliques and Coloring</a>
<ul>
<li class="toc-entry toc-h3"><a href="#centrality">Centrality</a></li>
<li class="toc-entry toc-h3"><a href="#cores">Cores</a></li>
<li class="toc-entry toc-h3"><a href="#degeneracy">Degeneracy</a></li>
<li class="toc-entry toc-h3"><a href="#clique">Clique</a>
<ul>
<li class="toc-entry toc-h4"><a href="#bron-kerbosch-algorithm">Bron-Kerbosch Algorithm</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#graph-coloring">Graph Coloring</a>
<ul>
<li class="toc-entry toc-h3"><a href="#greedy-algorithm">Greedy Algorithm</a></li>
<li class="toc-entry toc-h3"><a href="#register-allocation-and-strahler-numbers">Register Allocation and Strahler Numbers</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#chordal-graphs">Chordal Graphs</a>
<ul>
<li class="toc-entry toc-h3"><a href="#elimination-ordering-algorithm-lexicographic-bfs">Elimination Ordering Algorithm (Lexicographic BFS)</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#perfect-graphs">Perfect Graphs</a></li>
<li class="toc-entry toc-h2"><a href="#interval-graphs-and-path-decomposition">Interval Graphs and Path Decomposition</a>
<ul>
<li class="toc-entry toc-h3"><a href="#algorithms-1">Algorithms</a></li>
<li class="toc-entry toc-h3"><a href="#trees-and-pathwidths">Trees and Pathwidths</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#fpt">FPT</a></li>
</ul><h2 id="graph-representation">
<a class="anchor" href="#graph-representation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Graph Representation</h2>

<p>Want the following out of a graph data structure:
    - Count vertices: O(1)
    - Iterate through all vertices: O(1) per vertex
    - Associate information with vertices: O(1) per get/set
    - Iterate through all edges: O(1) per edge
    - Get degree of vertex: O(1)
    - Count all edges: O(1)
    - Iterate through edges in/out of a vertex: O(1) per edge
    - Associate information with edges: O(1) per get/set
    - Test whether two vertices are connected by an edge: O(1)</p>

<h3 id="decorator-pattern-and-adjacency-lists">
<a class="anchor" href="#decorator-pattern-and-adjacency-lists" aria-hidden="true"><span class="octicon octicon-link"></span></a>Decorator Pattern and Adjacency Lists</h3>

<p>Possible solutions:</p>

<ol>
  <li>Dictionary, with vertices as keys</li>
  <li>Number vertices and index an array using those numbers</li>
  <li>Separate variables for vertex objects for each piece of information</li>
  <li>One dictionary variable per vertex with keys for each piece of information</li>
</ol>

<ul>
  <li>An <strong>adjacency list</strong> uses a dictionary of vertices as keys and the list of outgoing neighbors as values
    <ul>
      <li>There are lots of different variations on this structure; different objects for vertices and edges</li>
    </ul>
  </li>
  <li>The Python-style dictionary representation satisfies the time constraints needed for an efficient PageRank algorithm
    <ul>
      <li>Some operations are not supported; e.g. looping through incoming edges can be slow</li>
    </ul>
  </li>
</ul>

<h2 id="bfsdfs">
<a class="anchor" href="#bfsdfs" aria-hidden="true"><span class="octicon octicon-link"></span></a>BFS/DFS</h2>

<ul>
  <li>
<strong>Implicit graph</strong>: A graph whose edges and vertices are not already given and must be found through an algorithm (like BFS)</li>
  <li>A <strong>path</strong> is an alternating sequence of endpoints and edges that does not allow repetition</li>
  <li>A <strong>walk</strong> is the same as a path but allows repetition</li>
  <li>
<strong>Reachability</strong>: Does there exist a path between two nodes? If so, then they are reachable from each other</li>
</ul>

<h2 id="minimum-spanning-trees">
<a class="anchor" href="#minimum-spanning-trees" aria-hidden="true"><span class="octicon octicon-link"></span></a>Minimum Spanning Trees</h2>
<ul>
  <li>Given an undirected graph, find a tree that connects all vertices and minimizes the total weight</li>
  <li>Disconnected graphs will output a <strong>spanning forest</strong> as opposed to a tree</li>
  <li>Minimize and maximize are the same problem; simply make weights negative</li>
</ul>

<h3 id="applications">
<a class="anchor" href="#applications" aria-hidden="true"><span class="octicon octicon-link"></span></a>Applications</h3>

<ul>
  <li>Build an optimal power grid/transportation routes with minimal total construction cost</li>
  <li>Build a computer network with maximum badwidth - maximum spanning tree</li>
  <li>The minimum spanning tree has the smallest possible bottle neck out of all trees; maximum has the largest</li>
</ul>

<h3 id="properties">
<a class="anchor" href="#properties" aria-hidden="true"><span class="octicon octicon-link"></span></a>Properties</h3>

<ul>
  <li>Assumes that there are no “tied” edges, and if they do have the same edge, then use a consistent tiebreaking method</li>
  <li>
<strong>Cycle property</strong>: If C is a cycle in the original graph G, then the heaviest edge in this cycle cannot be in the MST
    <ul>
      <li>In other words: If C is any cycle and e is its heaviest edge, then an MST that contains e will not be the MST</li>
    </ul>
  </li>
  <li>
<strong>Cut property</strong>: If we cut the vertices of the graph into any two subsets of vertices X and G - X, and e is the lihtest edge with endpoints in both subsets, then e must be in the MST
    <ul>
      <li>Can be used to derive algorithms</li>
    </ul>
  </li>
  <li>
<strong>Path property</strong>: For any two vertices x and y, the MST path from x to y has the minimum possible weight for its heaviest edge</li>
</ul>

<h3 id="algorithms">
<a class="anchor" href="#algorithms" aria-hidden="true"><span class="octicon octicon-link"></span></a>Algorithms</h3>

<ul>
  <li>Most algorithms to find an MST takes O(n log n) time and utilize the cut property</li>
  <li>Algorithms have been found that take close to linear time or expected linear time but randomized</li>
</ul>

<h4 id="jarniks-algorithm-prim-dijkstra">
<a class="anchor" href="#jarniks-algorithm-prim-dijkstra" aria-hidden="true"><span class="octicon octicon-link"></span></a>Jarnik’s Algorithm (Prim-Dijkstra)</h4>

<ul>
  <li>Start with some vertex S; this will be the start of the MST, named T</li>
  <li>Repeat until T contains all vertices:
    <ol>
      <li>Partition the graph into T and G - T</li>
      <li>Find the minimum-weight edge e connecting T and G - T</li>
      <li>Add e to T (as well as its corresponding vertex)</li>
    </ol>
  </li>
  <li>Can be implemented via a priority queue
    <ul>
      <li>Store vertices not yet in T by the weight of the minimum-weight edge that would connect it to T</li>
      <li>Update the priority queue each time you update T by looping through the edges</li>
    </ul>
  </li>
  <li>Using a binary heap, all find/remove operations take O(log n) time, so the total time is <strong>O(m log n)</strong> because each edge is looped over twice</li>
  <li>A Fibonacci heap can get this down to O(m + n log n)</li>
</ul>

<h4 id="kruskals-algorithm">
<a class="anchor" href="#kruskals-algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kruskal’s Algorithm</h4>

<ul>
  <li>Start by creating a forest of one-vertex trees</li>
  <li>Sort the edges by weight</li>
  <li>For each edge, if it connects two different trees, conenct the trees and add the edge to the MST</li>
  <li>O(m log m) for sorting, O(m) to iterate through list; <strong>O(m log m)</strong> total</li>
  <li>Can use the union-find data structure for near-constant lookups of forests</li>
</ul>

<h4 id="boruvkas-algorithm-sollin">
<a class="anchor" href="#boruvkas-algorithm-sollin" aria-hidden="true"><span class="octicon octicon-link"></span></a>Boruvka’s Algorithm (Sollin)</h4>

<ul>
  <li>Start by creating a forest of one-vertex trees</li>
  <li>Label vertices by their tree</li>
  <li>While there is more than one tree, find the minimum-weight outgoing edge from each forest
    <ul>
      <li>Add all of these minimum-weight edges to the T and connect the forests using them</li>
    </ul>
  </li>
  <li>The number of trees will go down by a factor of 2 or more, so we will do this iteration log n times</li>
  <li>Looping through all m edges per iteration means the runtime is <strong>O(m log n)</strong>
</li>
</ul>

<h4 id="hybrid-algorithm">
<a class="anchor" href="#hybrid-algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hybrid Algorithm</h4>
<ul>
  <li>Run Boruvka’s algorithm until the number of trees is less than or equal to n / log n</li>
  <li>Run Jarnik’s algorithm with Fiboniacci heaps, using a priority queue on the trees as opposed to the vertices</li>
  <li>O(m log log n) from Boruvka and O(m) from Jarnik means that the total runtime is O(m log log n)</li>
</ul>

<h2 id="topological-ordering">
<a class="anchor" href="#topological-ordering" aria-hidden="true"><span class="octicon octicon-link"></span></a>Topological Ordering</h2>

<ul>
  <li>
<strong>Topological ordering</strong>: A list of all vertices in G such that, for every edge $x \rightarrow y$, x is before y in the list</li>
  <li>
<strong>Topological sorting</strong>: An algorithm to compute a topological ordering</li>
  <li>Graphs that have cycles cannot have a topological ordering
    <ul>
      <li>Thus, only directed acyclic graphs can have a topological ordering</li>
    </ul>
  </li>
  <li>Can use a simple greedy algorithm; add vertices with no incoming edges to the ordering, and remove its outgoing edges from the graph
    <ul>
      <li>If there is ever a point where there are no “ready” vertices but there are still vertices left to process, then there is a cycle</li>
      <li>To find the cycle: go to a remaining vertex and walk forward until a vertex is repeated; the sequence between the repititions is the cycle</li>
    </ul>
  </li>
</ul>

<h2 id="shortest-and-longest-paths">
<a class="anchor" href="#shortest-and-longest-paths" aria-hidden="true"><span class="octicon octicon-link"></span></a>Shortest and Longest Paths</h2>

<ul>
  <li>Shortest path can found by BFS; longest path is NP-hard because it includes finding a Hamiltonian path
    <ul>
      <li>When there exists negative paths, then shortest path is NP-hard</li>
    </ul>
  </li>
  <li>Shortest walk is not possible if the graph has a negative cycle; can keep walking around the cycle and reducing total weight</li>
  <li>For finding shortest paths in directed graphs:
    <ul>
      <li>If graph is DAG, use topological ordering (O(m))</li>
      <li>If graph has nonnegative edge lengths, use Dijkstra’s (close to linear time)
        <ul>
          <li>Works on undirected graphs</li>
        </ul>
      </li>
      <li>If graph has negative edges but no negative cycle, use Bellman-Ford algorithm (O(mn))
        <ul>
          <li>Can also detect negative cycles if one exists</li>
        </ul>
      </li>
      <li>Bellman-Ford is optimal and can be improved based on recent results</li>
      <li>Dijkstra’s is “universally optimal” for a fixed graph with variable, positive weights</li>
    </ul>
  </li>
</ul>

<h3 id="critical-path-scheduling-pert-method">
<a class="anchor" href="#critical-path-scheduling-pert-method" aria-hidden="true"><span class="octicon octicon-link"></span></a>Critical Path Scheduling (PERT method)</h3>
<ul>
  <li>Input: a project consisting of multiple tasks that take different amounts of time</li>
  <li>Some tasks can be done simultaneously; others rely on earlier tasks to be completed</li>
  <li>Goal: Find a schedule for the tasks that finishes the project in the lowest possible time
    <ul>
      <li>AKA longest path finder</li>
    </ul>
  </li>
  <li>Can use an <strong>activity-on-edge</strong> graph; tasks are converted to edges, and vertices are project milestones
    <ul>
      <li>Constraints are represented by directed edges and have zero weight</li>
      <li>The <strong>critical path</strong> is the longest path in this graph from start to end and is the minimum possible time for the schedule</li>
      <li>Assign times to vertices by making sure that the difference between stages is greater than or equal to the length of the edge between them</li>
    </ul>
  </li>
  <li>To calculate the optimal schedule, we can use a topological ordering
    <ul>
      <li>Set the path length of the starting vertex to 0</li>
      <li>Find the largest incoming edge $u\rightarrow v$ and set the path length of v to $L(u) + weight(u \rightarrow v)$</li>
    </ul>
  </li>
  <li>Can find the smallest incoming edge to get the shortest paths</li>
</ul>

<h3 id="shortest-path-trees-and-relaxation-algorithms">
<a class="anchor" href="#shortest-path-trees-and-relaxation-algorithms" aria-hidden="true"><span class="octicon octicon-link"></span></a>Shortest Path Trees and Relaxation Algorithms</h3>

<ul>
  <li>In graphs without negative cycles, we can generate a tree of shortest paths</li>
  <li>If s is the starting vertex, then other vertices will have parents that are the vertices that come before them in their shortest path
    <ul>
      <li>e.g. if the shortest path from x to c is $x \rightarrow b \rightarrow c$, then b is a parent of c in the tree</li>
    </ul>
  </li>
  <li>Input: A graph with edge lengths and a starting vertex</li>
  <li>Output: Tree of shortest paths from s to all other reachable vertices
    <ul>
      <li>Two decorations per vertex: the parent and distance from start vertex</li>
    </ul>
  </li>
  <li>General idea: use the two decorations and update them when shorter paths are found</li>
  <li>Invariants
    <ul>
      <li>D is the length of some path to x that is greater than or equal to the correct value</li>
      <li>P is the second-to-last vertex on a path of length ≤D</li>
    </ul>
  </li>
  <li>Initialize by setting P(x) = None and D(x) = 0 if the vertex is s; otherwise D(x) = infinity</li>
  <li>For each edge uv, check whether the distance to u + the length of uv is less than the current shortest path for v, then update if so
    <ul>
      <li>Known as <strong>relaxing</strong> an edge</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def relax(u, v):
    if D[u] + length(edge uv) &lt; D[v]:
        D[v] = D[u] + length(edge uv)
        P[v] = u
</code></pre></div></div>

<ul>
  <li>If the graph is a DAG:
    <ul>
      <li>Simple algorithm is to go through vertices in topological order and relaxing each vertices’ edges</li>
      <li>Total time is O(m)</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>initialize D, P
for v in topological order:
    for incoming edges uv:
        relax(u, v)
</code></pre></div></div>

<h4 id="bellman-ford-algorithm">
<a class="anchor" href="#bellman-ford-algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bellman-Ford Algorithm</h4>
<ul>
  <li>Uses relaxation paradigm and takes O(mn) time</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>initialize D, P
repeat n-1 times:
    for each edge uv in the whole graph:
        relax(u, v)
</code></pre></div></div>

<ul>
  <li>Can be improved based on ordering of nodes or stopping early; still results in same big O</li>
</ul>

<h4 id="dijkstras-algorithm">
<a class="anchor" href="#dijkstras-algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dijkstra’s Algorithm</h4>

<ul>
  <li>Topologically sorts the shortest path tree by sorting vertices by distance
    <ul>
      <li>Uses a priority queue to order on the fly</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>initialize D, P
make priority queue Q of vertices, prioritized by D[v]
while Q is non-empty:
    find and remove minimum-priority vertex v in Q
    for each edge vw:
        relax(vw)
</code></pre></div></div>

<ul>
  <li>Takes O(m log n) with a binary heap or O(m + n log n) with a Fibonacci heap</li>
</ul>

<h3 id="changing-weights-without-changing-optimum-paths">
<a class="anchor" href="#changing-weights-without-changing-optimum-paths" aria-hidden="true"><span class="octicon octicon-link"></span></a>Changing Weights without Changing Optimum Paths</h3>

<ul>
  <li>We can add another decoration to the edges, a <em>height</em> h(x), to reweight the edges</li>
  <li>Each edge has two properties: length and height
    <ul>
      <li>New length: $l_h(u\rightarrow v) = l(u\rightarrow v) - h(u) + h(v)$</li>
      <li>Downhill edges have decreased length, uphill edges have increased length</li>
    </ul>
  </li>
  <li>Heights can eliminate negative edges and allow Dijkstra’s to work
    <ul>
      <li>Can now use Johnson’s and Suurballe’s algorithm</li>
      <li>Won’t get rid of negative cycles</li>
    </ul>
  </li>
  <li>Can also change the order of computation
    <ul>
      <li>A* algorithm uses this fact</li>
    </ul>
  </li>
</ul>

<h4 id="johnsons-algorithm">
<a class="anchor" href="#johnsons-algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Johnson’s Algorithm</h4>

<ul>
  <li>Input: A graph G with negative edges but not negative cycles</li>
  <li>Output: Shortest paths between all pairs of vertices</li>
</ul>

<ol>
  <li>Add a start vertex s that is connected to all other vertices by zero-weight edges</li>
  <li>Use Bellman-Ford only once to compute the shortest paths from s to all other vertices</li>
  <li>Reweight using the absolute value of distance from s as the height (guarantees that all edges are non-negative)</li>
  <li>Use Dijkstra from each starting vertex in the reweighted graph</li>
</ol>

<ul>
  <li>BF takes O(mn), reweighting takes linear time, Dijkstra is run n times; $O(mn + n^2 \text{log } n)$ time</li>
</ul>

<h3 id="suurballes-algorithm">
<a class="anchor" href="#suurballes-algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Suurballe’s Algorithm</h3>

<ul>
  <li>Input: A weighted directed graph and two endpoint vertices, s and t</li>
  <li>Output: Find two paths from s to t such that the paths don’t share edges and minimize the sum of the length of both</li>
  <li>Can find two shortest paths by finding one shortest path, then adding “reverse” edges with negative weights from the first shortest path
    <ul>
      <li>If both shortest paths take the same edge, then the edge will be cancelled out</li>
    </ul>
  </li>
</ul>

<ol>
  <li>Use Dijkstra to find single-source paths and distances from s</li>
  <li>Reweight the edges if they belong to a shortest path to equal 0</li>
  <li>Find shortest path P from s to t and reverse its edges</li>
  <li>Find a new shortest path in the modified graph</li>
  <li>Remove any edges visited in both paths and reconnect the paths</li>
</ol>

<ul>
  <li>Two runs of Dijkstra, linear time to reweight and reverse; total runtime of O(m + log n)</li>
</ul>

<h3 id="a">
<a class="anchor" href="#a" aria-hidden="true"><span class="octicon octicon-link"></span></a>A*</h3>

<ul>
  <li>Want to traverse paths to destination with Dijkstra without going down bad paths</li>
  <li>Idea: choose a height function for each vertex v that is easily to calculate and accurately estimates the distance from v to t
    <ul>
      <li>Must be an underestimate so paths to t eventually go downhill</li>
      <li>Can’t decrease too quickly; height between two vertices differs by at most the length of the edge between them</li>
      <li>AKA needs to be admissible</li>
    </ul>
  </li>
  <li>Reweight the graph by height function
    <ul>
      <li>Edges will be non-negative because of our height function</li>
      <li>Edges with smaller estimates appear shorter</li>
    </ul>
  </li>
  <li>Run Dijkstra on this reweighted graph
    <ul>
      <li>Same runtime as Dijkstra, but with linear time added to reweight</li>
    </ul>
  </li>
</ul>

<h2 id="widest-paths">
<a class="anchor" href="#widest-paths" aria-hidden="true"><span class="octicon octicon-link"></span></a>Widest Paths</h2>

<ul>
  <li>Input: A graph with weighted edges</li>
  <li>Output: Path from start to end with the maximum minimum weight (i.e. the path with the highest throughput, as given by the minimum edge weight on the path)</li>
</ul>

<h3 id="linear-algorithm">
<a class="anchor" href="#linear-algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Linear Algorithm</h3>

<ul>
  <li>For undirected graphs: if there is a single source and a single destination, the path can be found in <strong>linear time</strong>
    <ol>
      <li>Find median edge weight</li>
      <li>If a path can be made using heavier-than-median edges, get rid of lighter edges and recurse</li>
      <li>If a path cannot be made in this fashion, collapse connected components of wide edges into “supervertices” and recurse; combine edges</li>
    </ol>
  </li>
  <li>Linear time because $\Sigma \frac{m}{2^{i+1}} = O(m)$</li>
  <li>For directed graphs: we can use an algorithm that divides edges into subsets and runs linear time Dijkstra on these subsets in order to get a runtime of <strong>O(m log<sup>*</sup>n)</strong>
</li>
</ul>

<h3 id="dijkstra">
<a class="anchor" href="#dijkstra" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dijkstra</h3>

<ul>
  <li>We can modify the relax algorithm to prioritize widths of paths</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def relax(u, v):
    if v in Q and min(D[u], length(uv)) &gt; D[v]:
        D[v] = min(D[u], length(uv))
        P[v] = u
</code></pre></div></div>

<ul>
  <li>Same runtime as regular Dijkstra’s: <strong>O(m + n log n)</strong>
    <ul>
      <li>If edges are already sorted, then this algorithm runs in <strong>linear time</strong> using an integer priority queue</li>
    </ul>
  </li>
</ul>

<h4 id="all-pairs-directed-widest-paths">
<a class="anchor" href="#all-pairs-directed-widest-paths" aria-hidden="true"><span class="octicon octicon-link"></span></a>All-Pairs Directed Widest Paths</h4>

<ol>
  <li>Sort all the edges before finding paths (O(m log m))</li>
  <li>Run linear Dijkstra on each vertex (O(mn))</li>
  <li>Total runtime: <strong>O(mn + m log m)</strong>
</li>
</ol>

<ul>
  <li>Can also use fast matrix multiplication if the number of edges is large in $O(n^{2.688})$ time</li>
</ul>

<h3 id="applications-voting-systems">
<a class="anchor" href="#applications-voting-systems" aria-hidden="true"><span class="octicon octicon-link"></span></a>Applications: Voting Systems</h3>

<ul>
  <li>Instant runoff voting: Eliminate the candidate with the fewest amount of voters who have them as their favorite until a candidate has a majority</li>
  <li>Borda count: With c candidates, give candidates points based on their positioning in a voter’s preference ordering (first = c-1, second = c-2, last = 0); candidate with the most points wins</li>
  <li>Desirable properties
    <ul>
      <li>Majority: Candidate with a majority of first-place votes wins</li>
      <li>Weak majority: Candidate with all first-place votes wins</li>
      <li>Symmetry: All voters are treated equally</li>
      <li>Weak Symmetry: There is no super-voter whose preference decides the election</li>
      <li>No spoilers: If candidate X does not win the election, then removing X does not change the outcome (think third-parties)</li>
    </ul>
  </li>
  <li>Impossible to satisfy weak symmetry, weak majority, and no spoilers</li>
</ul>

<h4 id="condorcet-property--schulze-method">
<a class="anchor" href="#condorcet-property--schulze-method" aria-hidden="true"><span class="octicon octicon-link"></span></a>Condorcet Property / Schulze Method</h4>

<ul>
  <li>
<strong>Condorcet Property</strong>: If there is a candidate X who wins every head-to-head comparison, then X should win the election
    <ul>
      <li>If a cycle exists, then there is no apparent winner (i.e. A beats B, B beats C, C beats A)</li>
    </ul>
  </li>
  <li>Generate a graph where an edge from candidate U to V is weighted with the number of voters who prefer U to V</li>
  <li>Relabel each edge X to Y with the width of the widest path from X to Y in the original graph</li>
  <li>There is guaranteed to be a winner in this graph</li>
  <li>With randomized quickselect, this method takes $O(candidates^2 \cdot \log candidates)$</li>
</ul>

<p><img width="872" alt="Image" src="https://github.com/user-attachments/assets/7f9cc7fb-b78c-45e3-9107-9f6a87c71b31"></p>

<h2 id="euler-tours">
<a class="anchor" href="#euler-tours" aria-hidden="true"><span class="octicon octicon-link"></span></a>Euler Tours</h2>

<ul>
  <li>Defined as a walk through a graph such that each edge is visited once</li>
  <li>Note that, for any finite graph, there should be an even number of odd-degree vertices, as the sum of degrees should be even
    <ul>
      <li>A graph with no odd vertices has an Euler tour that starts and ends at the same vertex</li>
      <li>A graph with two odd vertices has an Euler tour that starts at one of the odd vertices and ends at the other</li>
    </ul>
  </li>
</ul>

<h3 id="fleurys-algortihm">
<a class="anchor" href="#fleurys-algortihm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fleury’s Algortihm</h3>

<ul>
  <li>Greedy algorithm: Keep adding edges without adding an edge that connects two uncovered parts of the graph</li>
  <li>Basic implementation is $O(m^2)$; check all edges when adding each edge</li>
  <li>Advanced implementations have better times, but still not linear</li>
</ul>

<h3 id="hierholzers-algorithm">
<a class="anchor" href="#hierholzers-algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hierholzer’s Algorithm</h3>

<ul>
  <li>Keep adding edges without checking whether or not we add an edge that connects to two uncovered parts of the graph</li>
  <li>After getting stuck, return to a vertex with uncovered edges and start a new tour
    <ul>
      <li>Splice the original tour with the new tour to create an Euler tour</li>
    </ul>
  </li>
  <li>Linear time complexity; each edge is visited once in either the original or a offshoot tour</li>
</ul>

<h2 id="traveling-salesman-problem">
<a class="anchor" href="#traveling-salesman-problem" aria-hidden="true"><span class="octicon octicon-link"></span></a>Traveling Salesman Problem</h2>

<ul>
  <li>Input: A connected undirected graph with nonzero positive edge lengths</li>
  <li>Goal: Find a walk that visits each vertex at least once and returns to the start index, minimizing the sum of edge lengths</li>
  <li>Can also be written as a distance problem
    <ul>
      <li>Input: A symmetric positive matrix of distances between points that satisfies the triangle inequality</li>
      <li>Goal: Find a cylcic order of points that uses each point exactly once, minimizing the sum of distances between points</li>
      <li>These two representations can be converted to each other</li>
    </ul>
  </li>
  <li>TSP is NP-hard, and even with unit edge lengths, it is NP-complete
    <ul>
      <li>Approximation ratio of 2 can be found with MSTs; theoretical best AR is $\frac{123}{122}$, but the best AR found is $\frac{3}{2} - \frac{1}{10^{36}}$</li>
      <li>These approximations run in polynomial time</li>
    </ul>
  </li>
</ul>

<h3 id="2-approximation">
<a class="anchor" href="#2-approximation" aria-hidden="true"><span class="octicon octicon-link"></span></a>2-Approximation</h3>

<ul>
  <li>Use the graph version so repeated vertices are allowed</li>
  <li>Find a MST and make a copy of each edge such that all degrees are now even</li>
  <li>Take an Euler tour of this graph and return it as the approximate TSP tour</li>
</ul>

<p><img width="508" alt="Image" src="https://github.com/user-attachments/assets/dc7c9755-4ad6-4fa9-a6ac-e5e41a9e22b5"></p>

<h3 id="32-approximation">
<a class="anchor" href="#32-approximation" aria-hidden="true"><span class="octicon octicon-link"></span></a>3/2-Approximation</h3>

<ul>
  <li>Construct an MST</li>
  <li>Identify the odd vertices in the MST
    <ul>
      <li>The number of odd vertices will be even by the handshaking lemma</li>
    </ul>
  </li>
  <li>Connect them in pairs using the shortest paths from the original graph, choosing the pairings that have the minimal sum of path lengths</li>
  <li>Combine the pair paths and the MST edges into one graph; return the Euler tour as the TSP tour</li>
</ul>

<h3 id="exact-dp-algorithm">
<a class="anchor" href="#exact-dp-algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Exact DP Algorithm</h3>

<ul>
  <li>Basic algorithm takes O(n!) time (try all permutations)</li>
  <li>Dynamic programming algorithm takes $O(2^nn^2)$ time
    <ul>
      <li>Preprocess the graph to get the all pairs shortest paths distance matrix</li>
      <li>Choose some starting vertex s</li>
      <li>Compute, for every subset of A of remaining vertices, and every vertex in A, the best path from s to v covering all vertices in A</li>
      <li>Choose v such that the path through all vertices to v + one more path back from v towards s has the minimum total length</li>
    </ul>
  </li>
</ul>

<p>Algorithm to compute the third step:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>L[A, v] is a table containing the length of the shortest tour starting at s, ending at v, covering all vertices in A
V(G) is the set of all vertices

for subset A in 1, 2, ..., 2^(n-1) - 1:
    for v in A:
        if A - v is empty:
            L[A, v] = D[n - 1, v]
        else:
            L[A, v] = min{L[A - v, u] + D[u, v] for u in A - v}

return min{L[V(G) - s, v] + D[v, n - 1] for v in V(G) - s}
</code></pre></div></div>

<h2 id="cliques-and-coloring">
<a class="anchor" href="#cliques-and-coloring" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cliques and Coloring</h2>

<h3 id="centrality">
<a class="anchor" href="#centrality" aria-hidden="true"><span class="octicon octicon-link"></span></a>Centrality</h3>

<ul>
  <li>
<strong>Centrality</strong>: A measure of how central (AKA how well-connected) a node is
    <ul>
      <li>There exist various measures of centrality, such as degree and pagerank</li>
    </ul>
  </li>
  <li>
<em>Closeness centrality</em>: $\frac{1}{\text{average distance to other vertices}}$
    <ul>
      <li>Closeness centrality can be calculated by computing the all-pairs shortest paths and averaging the distances; O(mn)</li>
      <li>Approximate algorithm exists where k vertices are chosen and we calculate the distances to these k vertices in O(km)
        <ul>
          <li>Graphs with the small world property (all distances ≤ D) leads to lower variance; setting k to $D \log n / \varepsilon^2$ gives a $(1+\varepsilon)$-approximation in time $O(\frac{m}{\varepsilon^2} \log n)$</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
<em>Betweenness centrality</em> attempts to find a vertex that is on many shortest paths
    <ul>
      <li>Formula: $\sum_{u, w\neq v} \frac{\text{No. of shortest paths from u to w through v}}{\text{No. of shortest paths from u to w}}$</li>
      <li>Optimal algorithm takes O(mn) time</li>
    </ul>
  </li>
</ul>

<h3 id="cores">
<a class="anchor" href="#cores" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cores</h3>

<ul>
  <li>A <strong>k-core</strong> of a graph is the largest subgraph in which all vertices have a degree ≥ k
    <ul>
      <li>Can be found by deleting vertices of degree &lt; k until there are none left</li>
    </ul>
  </li>
</ul>

<p>Algorithm for computing all cores simultaneously:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def cores(G):
    core = dict()
    current_core = 0
    while G is non-empty:
        v = a minimum-degree vertex
        current_core = max(current_core, degree(v))
        core[v] = current_core
        delete V from G
    return core
</code></pre></div></div>

<ul>
  <li>Can be made efficient by decorating each vertex with the number of uncovered neighbors (intially its degree) and updating + maintaining a dictionary with degrees as keys and lists of unprocessed nodes as values</li>
  <li>Takes O(sum of all degrees) = O(m) time</li>
</ul>

<h3 id="degeneracy">
<a class="anchor" href="#degeneracy" aria-hidden="true"><span class="octicon octicon-link"></span></a>Degeneracy</h3>

<ul>
  <li>Many definitions; one is the largest k for which a nonempty k-core exists</li>
</ul>

<h3 id="clique">
<a class="anchor" href="#clique" aria-hidden="true"><span class="octicon octicon-link"></span></a>Clique</h3>

<ul>
  <li>A <strong>clique</strong> is a subset of a graph for which all pairs are connected by an edge
    <ul>
      <li>Maximum clique is the biggest clique in the graph; a maximal clique is a clique to which no more vertices can be added while maintaining the clique property</li>
      <li>Independent set problem and clique problem are equivalent; add edges between vertices that are unconnected, and remove existing edges
        <ul>
          <li>NP-hard to find the maximum clique</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>There exist various algorithms to find all maximal cliques</li>
  <li>The <strong>Moon-Moser Theorem</strong> states that the maximum number of maximal cliques is $\leq 3^{n/3}$</li>
</ul>

<h4 id="bron-kerbosch-algorithm">
<a class="anchor" href="#bron-kerbosch-algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bron-Kerbosch Algorithm</h4>

<ul>
  <li>Uses recursive backtracking with three sets
    <ul>
      <li>R is the set of vertices containing the current clique being built</li>
      <li>P is the set of potential new vertices (that are adjacent to ones in R)</li>
      <li>X is the set of vertices that have already been added to a clique and should not be explored</li>
    </ul>
  </li>
  <li>Optimizations can be made
    <ul>
      <li>Choose a pivot $p \in P \cup X$ with the smallest number of non-neighbors in P and only loop over these neighbors
        <ul>
          <li>p’s neighbors will also be in a found clique, so the only vertices that can be added to R are its non-neighbors</li>
        </ul>
      </li>
      <li>Use the reverse degeneracy ordering so we don’t have to loop over so many vertices</li>
    </ul>
  </li>
  <li>Overall run time is $O(dn3^{d/3})$</li>
</ul>

<h2 id="graph-coloring">
<a class="anchor" href="#graph-coloring" aria-hidden="true"><span class="octicon octicon-link"></span></a>Graph Coloring</h2>

<ul>
  <li>Input: A graph</li>
  <li>Output: A coloring of vertices in the graph such that no neighboring vertices have the same color</li>
  <li>
<strong>Four color theorem</strong>: If a planar graph can be drawn without crossing edges, then it can be colored with at most four colors</li>
  <li>Two color graphs are <strong>bipartite</strong> and are easy to test for, but testing for a 3-coloring is NP-complete</li>
</ul>

<h3 id="greedy-algorithm">
<a class="anchor" href="#greedy-algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Greedy Algorithm</h3>
<ol>
  <li>Order the vertices</li>
  <li>Number the available colors (1, 2, 3, …)</li>
  <li>For each vertex in the ordering, give it the lowest-numbered color that is not used by one (or more) of its neighbor
    <ul>
      <li>O(degree) per node, O(m) total runtime</li>
      <li>If vertices are ordered in degeneracy ordering, then the greedy algorithm will use at most d + 1 colors</li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def first_unused(v):
    used = { color(w) for w in neighbors of v }
    for c in 1, 2, ... 
        if c not in used: return c
</code></pre></div></div>

<ul>
  <li>This algorithm is optimal for interval graphs (using a left-to-right ordering)</li>
</ul>

<h3 id="register-allocation-and-strahler-numbers">
<a class="anchor" href="#register-allocation-and-strahler-numbers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Register Allocation and Strahler Numbers</h3>

<ul>
  <li>Problem: Calculate an expression using the minimum number of registers at any given time</li>
  <li>If two expressions A and B require a and b registers respectively, then we will need to store the answer to one of them while doing the other
    <ul>
      <li>If A is calculated first, then max(a, b+1) registers are use; otherwise, max(b, a+1) registers are used</li>
      <li>Calculate intensive expressions first to save the +1 constant</li>
    </ul>
  </li>
  <li>Bottom-up calculation of optimal ordering
    <ul>
      <li>If a node x is a leaf, then the number of calculations R(x) is 1</li>
      <li>If x has two children y and z, then evaulate the one with the larger subtree first, so R(x) = max(R(y), R(z))</li>
      <li>If R(y) = R(z), then R(x) = R(y) + 1 = R(z) + 1</li>
    </ul>
  </li>
  <li>This bottom-up calculation also produces the <strong>Strahler numbers</strong> of nodes in a tree</li>
  <li>This problem can be written as a graph coloring problem
    <ul>
      <li>Vertices are the local variables of the intermediate code</li>
      <li>Edges are local variables that need to be stored at the same time</li>
      <li>Colors are available registers</li>
    </ul>
  </li>
</ul>

<h2 id="chordal-graphs">
<a class="anchor" href="#chordal-graphs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chordal Graphs</h2>

<ul>
  <li>A graph is a <strong>chordal graph</strong> if and only if one of the following conditions are satisfied:
    <ol>
      <li>Every cycle longer than three vertices has a <strong>chord</strong>, or another edge connecting two vertices of the cycle</li>
      <li>It has an <strong>elimination ordering</strong>: An ordering of the vertices where the later neighbors of every vertex form a clique</li>
      <li>For every two vertices x and y and every minimal subset S whose deletion would separate x from y, S is a clique</li>
    </ol>
  </li>
  <li>Definition 1 is analagous to a graph with no holes, where a <strong>hole</strong> is a cycle of at least length 4 that does not have a chord</li>
</ul>

<h3 id="elimination-ordering-algorithm-lexicographic-bfs">
<a class="anchor" href="#elimination-ordering-algorithm-lexicographic-bfs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Elimination Ordering Algorithm (Lexicographic BFS)</h3>

<ul>
  <li>If G has an elimination ordering, so does G - v</li>
  <li>Slow, basic algorithm: find vertices whose neighbors form a clique and delete it</li>
  <li>We can check validity of an elimination order in linear time; for each vertex v, check that all later neighbors of v are neighbors of w (the neighbor of v that is next in the ordering)
    <ul>
      <li>This can be done using BFS</li>
      <li>
<strong>Lexicographic ordering</strong>: Given an ordering of vertices, define $pred_i(v)$ to be the ith neighbor of v or v itself if there are fewer than i neighbors earlier than v; order these vertices based on the tuple ${pred_1(v), pred_2(v), …, pred_n(v)}$</li>
    </ul>
  </li>
  <li>Algorithm for finding lexicographic order
    <ul>
      <li>Maintain a sequence of sets of unprocessed vertices, initially in one big set</li>
      <li>While this sequence is nonempty:
        <ol>
          <li>Let $S_i$ be the first set in the sequence and v be any vertex in this set</li>
          <li>Remove v from $S_i$ (and remove $S_i$ if it becomes empty)</li>
          <li>Output v; let N(v) be the set of neighbors of v</li>
          <li>For each set $S_j$ in the sequence, split $S_j$ into two sets $S_j \cap N(v)$ and $S_j \backslash N(v)$</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>We can use dynamic sets, linked lists, and dictionaries to get $O(\vert N(v)\vert)$ time</li>
</ul>

<h2 id="perfect-graphs">
<a class="anchor" href="#perfect-graphs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Perfect Graphs</h2>
<ul>
  <li>A graph is <strong>perfect</strong> if the optimal number of colors equals the number of vertices in the largest clique
    <ul>
      <li>Deleting any vertex in this graph will produce another perfect graph
        <ul>
          <li>This property is true for interval, chordal, and bipartite graphs</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
<strong>Strong Perfect Graph Theorem</strong>: A graph G is perfect if and only if it has no odd-length holes AND its complement has no odd-length holes
    <ul>
      <li>Implies the “weak perfect graph theorem” that complement of perfect graphs are perfect</li>
    </ul>
  </li>
  <li>Perfect graphs can be found in polynomial time ($O(n^9)$)</li>
  <li>An optimal method for coloring and finding cliques in perfect graphs takes polynomial time but is complex</li>
  <li>Interval graphs $\in$ chordal graphs $\in$ perfect graphs</li>
</ul>

<h2 id="interval-graphs-and-path-decomposition">
<a class="anchor" href="#interval-graphs-and-path-decomposition" aria-hidden="true"><span class="octicon octicon-link"></span></a>Interval Graphs and Path Decomposition</h2>

<ul>
  <li>An <strong>interval graph</strong> is defined as a graph with nodes representing intervals and edges representing overlaps of two intervals</li>
  <li>We can rewrite an interval graph using <strong>bags</strong> where each interval segment is labeled by the intervals that overlap during it
    <ul>
      <li>Get rid of bags that are not subsets of larger bags</li>
      <li>The intervals can be recovered from the path decomposition</li>
      <li>This is known as the <strong>interval graph path decomposition</strong>
</li>
    </ul>
  </li>
</ul>

<p><img width="655" alt="Image" src="https://github.com/user-attachments/assets/98392fd9-4d9a-4647-b097-a7968ab33f63"></p>

<ul>
  <li>Properties of the interval graph path decomposition
    <ul>
      <li>Each vertex belongs to a consecutive sequence of bags</li>
      <li>Edges are pairs of vertices that both appear in the same bag</li>
      <li>The largest clique is the biggest bag</li>
      <li>Each edge has both its endpoints in some bag</li>
    </ul>
  </li>
  <li>
<strong>Path decomposition</strong>: get rid of the intervals and use a sequence of bags with the following properties
    <ul>
      <li>Each vertex appears in a consecutive subsequence of bags</li>
      <li>Every edge has ≥ 1 bag containing both endpoints</li>
    </ul>
  </li>
  <li>One graph can have many different path decompositions
    <ul>
      <li>The <em>width</em> of a decomposition is the size of the biggest bag minus 1</li>
      <li>The pathwidth of a graph is the smallest width of any decomposition</li>
      <li>The pathwidth of a graph can also be defined as the smallest possible max clique size (minus one) of an interval graph containing G</li>
    </ul>
  </li>
  <li>Vertices of a clique have overlapping subsequences of bags
    <ul>
      <li>Some bag contains the whole clique</li>
    </ul>
  </li>
</ul>

<h3 id="algorithms-1">
<a class="anchor" href="#algorithms-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Algorithms</h3>
<p>Fast clique finding with a low-width path decomposition:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for each bag in the path decomposition:
    for each subset of the bag:
        if it's a clique bigger than the best found so far
            remember it as max clique
</code></pre></div></div>

<ul>
  <li>Outer loop is O(n), inner loop is $O(2^w)$, so $O(n2^w)$ time</li>
</ul>

<p>Fast coloring:</p>
<ul>
  <li>We can use a dynamic programming algorithm to color a graph fast</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for each bag B in left-to-right order, and each coloring C with ≤ k colors:
    let B' be the bag just before B
    Good(B, C) = true if C is compatible with a good coloring of B'
</code></pre></div></div>

<ul>
  <li>G has a k-coloring if and only if its last bad has a good coloring</li>
  <li>Time takes $O(nk^{w+1})$</li>
</ul>

<h3 id="trees-and-pathwidths">
<a class="anchor" href="#trees-and-pathwidths" aria-hidden="true"><span class="octicon octicon-link"></span></a>Trees and Pathwidths</h3>

<ul>
  <li>Trees are easy to find cliques and easy to color but can have large pathwidth - must be a way to decompose them</li>
  <li>
<strong>Tree decomposition</strong> involves making a tree of bags instead of a sequence of bags
    <ul>
      <li>Every vertex must belong to a connected subtree of bags</li>
      <li>Every edge must have both endpoints in at least one bag</li>
    </ul>
  </li>
  <li>
<strong>Treewidth</strong>: the smallest width of any tree decomposition, or the smallest possible max clique size (minus one) of a chordal graph that contains G
    <ul>
      <li>The tree decomposition can be used in the algorithms that use path decompositions but will work better because more graphs have smaller treewidth</li>
    </ul>
  </li>
</ul>

<h2 id="fpt">
<a class="anchor" href="#fpt" aria-hidden="true"><span class="octicon octicon-link"></span></a>FPT</h2>

<ul>
  <li>
<strong>Fixed parameter tractable</strong>: Time is polynomial n with a fixed exponent, but may depend badly on width</li>
  <li>
<strong>Courcelle’s theorem</strong>: There exists an FPT algorithm for any existence or min-weight/max-weight optimization problem on classes of graphs that can be described as a logical formula involving vertices, edges, sets of vertices and edges, and adjacency</li>
</ul>

  </div><a class="u-url" href="/college-notes/cs163/lecture/winter25/markdown/2025/01/06/cs163-lecture.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/college-notes/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="https://tonyhieu.github.io/college-notes/feed.xml">
            <svg class="svg-icon orange">
              <path d="M12.8 16C12.8 8.978 7.022 3.2 0 3.2V0c8.777 0 16 7.223 16 16h-3.2zM2.194
                11.61c1.21 0 2.195.985 2.195 2.196 0 1.21-.99 2.194-2.2 2.194C.98 16 0 15.017 0
                13.806c0-1.21.983-2.195 2.194-2.195zM10.606
                16h-3.11c0-4.113-3.383-7.497-7.496-7.497v-3.11c5.818 0 10.606 4.79 10.606 10.607z"
              />
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>Site to document notes for various classes</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li>
    <a rel="me" href="" target="_blank" title="">
      <span class="grey fa-brands fa- fa-lg"></span>
    </a>
  </li><li>
    <a rel="me" href="" target="_blank" title="">
      <span class="grey fa-brands fa- fa-lg"></span>
    </a>
  </li></ul>
</div>

  </div>

</footer>
</body>

</html>
